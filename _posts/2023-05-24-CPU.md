---
layout: post
title: CPU(중앙 처리 장치)
date: 2023-05-24 13:00:00 +0900
categories: ComputerStructure
tags: ComputerStructure CPU
---

# CPU (central processing unit)
-------------
CPU는 메모리에 저장된 명령어를 읽어 들이고, 해석, 실행하는 장치입니다.

먼저 ALU와 제어장치에 대해 알아 봅시다.

<img width="400" alt="CPU" src="https://github.com/bum-su/bum-su.github.io/assets/69189889/b6aa8507-f8e8-4346-a772-2eb8fb18cda6"><br/><br/>

# ALU (arithmetic and logical unit)
---------------

<img width="639" alt="ALU" src="https://github.com/bum-su/bum-su.github.io/assets/69189889/71971231-d8ce-4163-aacc-89b740ed1405">

ALU는 레지스터를 통해 피연산자를 받아들이고, 제어장치로부터 수행할 연산을 알려주는 제어 신호를 받아들입니다.

연산을 수행한 결과는 특정 숫자나 문자가 될 수도 있고, 메모리 주소가 될 수도 있습니다.

그리고 결과값은 일시적으로 레지스터에 저장됩니다.

왜냐하면 CPU가 메모리에 접근하는 속도보다 레지스터에 접근하는 속도가 빠르기 때문입니다.<br/>

ALU가 연산할 때 마다 결과를 메모리에 저장한다면, CPU는 메모리에 자주 접근하게 되어 프로그램 속도를 늦출 수 있습니다.

그래서 ALU의 결과값은 AM에 바로 저장되는 것이 아니라 레지스터에 우선 저장합니다.<br/><br/>

### 플래그

결과값이 음수인지 양수인지 판단하거나 연산 결과를 담을 레지스터보다 결과가 클 때 '결과값이 크다'라는 추가 정보를 내보냅니다. (overflow)

이런 연산 결과에 대한 추가 정보를 플래그라고 합니다.

그리고 플래그들은 플래그 레지스터에 저장됩니다.<br/><br/>

## 제어장치
-----------
제어장치는 제어 신호를 내보내고, 명령어를 해석하는 부품입니다.

**제어 신호**는 컴퓨터 부품들을 관리하고 작동시키기 위한 일종의 전기 신호입니다.

<img width="845" alt="ControlUnit" src="https://github.com/bum-su/bum-su.github.io/assets/69189889/698bdf2f-1327-4df4-aa07-0bdabdea9b1e"><br/>

### 먼저 제어 장치는 클럭 신호부터 받습니다

클럭이란 컴퓨터의 모든 부품을 움직일 수 있게 하는 시간 단위 입니다.

클럭 주기에 맞춰 레지스터에서 다른 레지스터로 데이터가 이동하거나, ALU에서 연산이 수행되거나, CPU가 메모리에 저장된 명령어를 읽어 들입니다.

다만, 컴퓨터 부품들은 클럭이라는 박자에 맞춰 작동할 뿐 한 박자마다 작동하진 않습니다.<br/><br/>

### 제어장치는 해석해야 할 명령어를 받습니다

CPU가 해석해야 할 명령어는 명령어 레지스터에 저장됩니다. 제어장치는 명령어 레지스터로부터 해석할 명령어를 받아들이고 해석한 뒤, 제어 신호를 발생시켜 컴퓨터 부품들에 수행해야 할 내용을 전달합니다.<br/><br/>

### 제어장치는 플래스 레지스터 속 플래그 값을 받습니다

플래그는 ALU 연산에 대한 추가적인 상태 정보입니다,<br/>제어장치는 플래그 값을 받고 이를 참고하여 제어신호를 발생시킵니다.
<br/><br/>

## 제어장치는 시스템 버스, 그 중 제어 버스로 전달된 제어 신호를 받습니다

제어장치는 제어 버스를 통해 외부로부터 전달된 제어 신호를 받아들이기도 합니다.

### 제어 장치가 외부에 내보내는 정보

제어장치가 CPU 외부에 제어 신호를 전달하는 것은, 제어 버스로 제어 신호를 내보낸다는 말과 같습니다.
<br/><br/>
이런 제어 신호는 메모리에 전달하는 제어 신호와 입출력장치에 전달하는 제어 신호가 있습니다.
(입출력 장치는 보조기억장치도 포함합니다)
<br/><br/>
메모리에 저장된 값을 읽거나 새로운 값을 쓸려고 하면 메모리로 제어 신호를 내보냅니다. <br/>
그리고 입출력장치의 값을 읽거나 새로운 값을 쓰고 싶을 때는 입출력장치로 제어 신호를 내보냅니다.

### 제어 장치가 내부에 내보내는 정보

크게 ALU에 전달하는 제어 신호와 레지스터에 전달하는 제어 신호가 있습니다.<br/>
ALU에는 수행할 연산을 지시하기 위해, 레지스터에는 레지스터 간에 데이터를 이동시키거나 레지스터에 저장된 명령어를 해석하기 위해 제어 신호를 보냅니다.
<br/><br/>

# 레지스터
--------------
- 프로그램 카운터
- 메모리 주소 레지스터
- 메모리 버퍼 레지스터
- 명령어 레지스터
- 플래그 레지스터
- 범용 레지스터
- 스택 포인터
- 베이스 레지스터

각 레지스터가 CPU 내부에서 어떤 역할을 수행하는지 알아봅시다.

### 프로그램 카운터 (PC : Program Counter)

메모리에서 가져올 명령어의 주소, 즉 메모리에서 읽어 들일 명령어의 주소를 저장합니다.

명령어 포인터(IP : Instruction Pointer)라고 부르는 CPU도 있습니다.

### 메모리 주소 레지스터 (MAR : Memory Address Resgister)

메모리의 주소를 저장하는 레지스터입니다. <br/>
CPU가 읽어 들이려 하는 주소 값을 주소 버스로 보낼 때, 메모리 주소 레지스터를 거칩니다.

### 메모리 버퍼 레지스터 (MBR : Memory Buffer Register)

메모리와 주고받을 값(데이터와 명령어)을 저장하는 레지스터입니다.<br/>
메모리에 쓰고 싶은 값이나 메모리부터 전달받은 값은 메모리 버퍼 레지스터를 거칩니다.

CPU가 주소 버스로 내보낼 값이 메모리 주소 레지스터를 거친다면, 데이터 버스로 주고 받을 값은 메모리 버퍼 레지스터를 거칩니다.

### 명령어 레지스터 (IR : Instruction Register)

해석할 명령어, 방금 메모리에서 읽어 들인 명령어를 저장하는 레지스터입니다. <br/>
제어장치는 명령어 레지스터 속 명령어를 받아 이를 해석한 뒤 제어 신호를 내보냅니다.

### 범용 레지스터 (General purpose Register)

다양하고 일반적인 상황에서 자유롭게 사용할 수 있는 레지스터입니다. <br/>
데이터와 주소를 모두 저장할 수 있습니다. <br/>

CPU 안에는 여러 개의 범용 레지스터들이 있고, 현대 대다수 CPU는 모두 범용 레지스터를 가지고 있습니다.

### 플래스 레지스터

ALU 연산 결과에 따른 플래그를 플래그 레지스터에 저장합니다. <br/>
플래그 레지스터는 연산 결과 또는 CPU 상태에 대한 부가적인 정보를 저장하는 레지스터입니다.

### 스택 포인터
스택 포인터는 스택 주소 지정 방식이라는 주소 지정 방식에 사용됩니다.

**스택 주소 지정 방식**은 스택과 스택 포인터를 이용한 주소 지정 방식입니다.

**스택 포인터**란 스택의 꼭대기를 가리키는 레지스터입니다. 즉, 스택에 마지막으로 저장한 값의 위치를 저장하는 레지스터 입니다.

## 변위 주소 지정 방식
명령어는 연산 코드와 오퍼랜드로 이루어져 있습니다.

변위 주소 지정 방식이란 오퍼랜드 필드의 값과 특정 레지스터의 값을 더하여 유효 주소를 얻어내는 주소 지정 방식입니다.

이 때, 변위 주소 지정 방식은 오퍼랜드 필드의 주소와 어떤 레지스터를 더하는지에 따라 상대 주소 지정방식, 베이스 레지스터 주소 지정 방식 등으로 나뉩니다.

### 상대 주조 시정 방식

오퍼랜드와 프로그램 카운터의 값을 더하여 유효 주소를 얻는 방식입니다.

프로그램 카운터에는 읽어 들일 명령어의 주소가 저장되어 있습니다. <br/>
만약 오퍼랜드가 음수. -3이라면, CPU는 읽어 들이기로 한 명령어로부터 '세 번째 이전' 주소로 접근합니다.

### 베이스 레지스터 주소 지정 방식
오퍼랜드와 베이스 레지스터의 값을 더하여 유효 주소를 얻는 방식입니다.

베이스 레지스터는 '기준 주소', 오퍼랜드는 '기준 주소로부터 떨어진 거리'의 역할을 합니다. <br/>
베이스 레지스터의 기준 주소로 부터 얼마나 떨어져 있는 주소에 접근할 것인지를 연산하여 유효 주소를 얻어내는 방식입니다.

기준 주소가 200이고 40만큼 떨어진 240에 접근한다고 생각하면 됩니다.

- 프로그램 카운터는 메모리에서 가져올 명령어의 주소를 저장
- 메모리 주소 레지스터는 메모리의 주소를 저장
- 메모리 버퍼 레지스터는 메모리와 주고받을 데이터를 저장
- 명령어 레지스터는 해석할 명령어를 저장
- 범용 레지스터는 데이터와 주소를 모두 저장
- 플래스 레지스터는 연산 결과나 CPU 상태에 대한 부가 정보를 저장
- 스택 포인텅는 스택 최상단의 위치를 저장
- 베이스 레지스터에 저장된 주소는 기준 주소로서의 역할을 합니다.

# 명령어 사이클과 인터럽트
----------------

하나의 명령어를 처리하는 정형화된 흐름을 명령어 사이클이라고 합니다.

간혹 이 흐름이 끊어지는 상황이 발생하는데 이를 인터럽트라고 합니다.

## 명령어 사이클
----------
CPU는 명령어들을 하나씩 실행합니다.<br/>
이때 프로그램 속 각 명령어들은 일정한 주기가 반복되며 실행되는데, 이 주기를 명령어 사이클이라고 합니다.

<img width="571" alt="InstructionCycle" src="https://github.com/bum-su/bum-su.github.io/assets/69189889/7548fdae-e9f0-4d5f-aefe-744c940ea517">

메모리에 있는 명령어를 CPU로 가지고 오는 단계를 인출 사이클이라고 합니다.

CPU로 가져온 명령어를 실행하는 단계를 실행 사이클이라고 합니다.  (제어장치가 명령어 레지스터에 담긴 값을 해석하고, 제어 신호를 발생시키는 단계가 실행 사이클입니다.)

인출, 실행 사이클로만 명령어가 간단히 실행되는 경우도 있지만 간접 사이클이 끼는 경우도 있습니다.

그건 간접 주소 지정 방식입니다.<br/>
명령어를 인출하여 CPU로 가져왔다 하더라도 바로 실행 사이클에 돌입할 수 없습니다.

명령어를 실행하기 위해서는 메모리 접근을 한 번 더 해야 하기 때문입니다.

그렇기에 어떤 명령어는 인출과 실행 사이클만으로 실행되고, 어떤 명령어는 인출, 간접, 실행 사이클을 거쳐 실행됩니다.

## 인터럽트
------------
CPU가 수행 중인 작업은 방해를 받아 잠시 중단될 수 있는데,<br/> CPU의 작업을 방해하는 신호를 인터럽트라고 합니다.

인터럽트의 종류에는 크게 동기 인터럽트와 비동기 인터럽트가 있습니다.

### 동기 인터럽트

CPU에 의해 발생하는 인터럽트입니다.<br/>
CPU가 명령어들을 수행하다가 예상치 못한 상황에 마주쳤을 때 발생합니다. (예외 처리 같은 것들)

### 비 동기 인터럽트

입출력장치에 의해 발생하는 인터럽트입니다.<br/>

키보드, 마우스와 같은 장치에 입력을 받았을 때 이를 처리하기 위해 CPU에 입력 인터럽트를 보낸다고 생각하면 됩니다.

### 하드웨어 인터럽트 처리 순서
1. 입출력장치는 CPU에 입터럽트 요청 신호를 보냅니다.
2. CPU는 실행 사이클이 끝나고 명령어를 인출하기 전 항상 인터럽트 여부를 확인합니다.
3. CPU는 인터럽트 요청을 확인하고 인터럽트 플래그를 통해 현재 인터럽트를 받아들일 수 있는지 여부를 확인합니다.
4. 인터럽트를 받아들일 수 있다면 CPU는 지금까지의 작업을 백업합니다.
5. CPU는 인터럽트 벡터를 참조하여 인터럽트 서비스 루틴을 실행합니다.
6. 인터럽트 서비스 루틴 실행이 끝나면 4에서 백업해 둔 작업을 복구하여 실행을 재개합니다.

- 인터럽트 요청 신호 : CPU의 작업을 방해하는 인터럽트의 대한 요청
- 인터럽트 플래크 : 인터럽트 요청 신호를 받아들일지 무시할지를 결정하는 비트
- 인터럽트 벡터 : 인터럽트 서비스 루틴의 시작 주소를 포함하는 인터럽트 서비스 루틴의 식별 정보
- 인터럽트 서비스 루틴 : 인터럽트를 처리하는 프로그램

<img width="632" alt="InstructionCycle2" src="https://github.com/bum-su/bum-su.github.io/assets/69189889/3ad02871-d454-41ba-9b3e-2c21e0103e03">