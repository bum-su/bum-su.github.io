---
layout: post
title: "Memory"
date: 2023-05-05 18:34:00 +0900
categories: C++ Variable
tags: Memory MemoryLeak 
---

# 서론
지역 변수는 **스택 영역**에 <br/>
정적, 전역 변수는 **DATA 영역**에 <br/>
동적 변수는 **힙 영역**에 메모리가 할당된다고 한다. <br/>
마지막으로 코드 영역은 실행할 프로그램의 코드가 할당 된다.<br/><br/>

그럼
**araboza**

## 메모리 구조
----------------
메모리는 대개 다음 영역으로 구분된다.
- 코드 영역 : 실행 가능한 코드가 저장되는 영역
- 데이터 영역 : 전역 변수와 정적 변수가 저장되는 영역 (BSS, DATA)
- 힙 영역 : 동적으로 할당된 메모리가 저장되는 영역
- 스택 영역 : 함수 호출과 지역 변수에 대한 메모리가 저장되는 영역

![memory](https://user-images.githubusercontent.com/69189889/236433871-b81dd30b-3810-403e-86c3-36acd849a080.png)
https://ko.wikipedia.org/wiki/%EB%8F%99%EC%A0%81_%EB%A9%94%EB%AA%A8%EB%A6%AC_%ED%95%A0%EB%8B%B9

## 스택 영역
----------
- LIFO(Last In, First Out) : 가장 최근에 할당된 메모리 블록이 가장 먼저 해제되는 방식을 사용한다. (윈도우 기준, 높은 메모리 주소에서 낮은 메모리 주소 방향으로 쌓인다.)
- 스택 영역에 할당된 메모리는 해당 변수가 범위를 벗어나거나 함수가 종료되면 자동으로 해제된다.
- 여기서 **스택 포인터**를 이용해 메모리를 할당하거나 해제한다.
- 스택 영역의 크기는 프로그램 시작 시 결정되며, 런타임 동안 변경되지 않는다. 따라서 스택에 너무 많은 메모리를 할당하면 **스택 오버플로우**가 발생할 수 있다.

```cpp 
#include <stdio.h>

void functionB() {
    int localVarB = 10; // 지역 변수 할당 (스택 영역)
    printf("Local variable in function B: %d\n", localVarB);
} // 함수 종료 시 localVarB 메모리가 해제된다

void functionA() {
    int localVarA = 5; // 지역 변수 할당 (스택 영역)
    printf("Local variable in function A: %d\n", localVarA);
    functionB(); // functionB 호출
} // 함수 종료 시 localVarA 메모리가 해제된다

int main() {
    functionA(); // functionA 호출
    return 0;
}

```
**지역 변수와 매개 변수들은 일시적으로 사용되는 특성이 있다. 그렇기 때문에 함수가 종료되면 메모리를 효율적으로 관리하기 위해 스택에 할당된다.**

## 힙 영역
---------------
 - 힙 영역은 프로그램 실행 중 필요한 만큼 메모리를 동적으로 할당할 수 있다. **( 요청된 크기에 맞는 충분한 연속 메모리 공간을 찾고, 이 과정에서 사용 가능한 메모리 블록들 중 적절한 공간을 찾아 할당)**
 - 힙 영역에서 할당된 메모리는 개발자가 명시적으로 해제해야 한다. 하지 않으면 **메모리 누수**가 발생할 수 있다. 
 - 힙 영역의 메모리 할당은 **메모리 관리자(memory manager)**에 의해 관리된다. 메모리 관리자는 요청된 메모리 크기에 맞는 메모리 블록을 할당하고, 메모리 해제 요청을 처리한다.
 - 힙 영역에선 메모리를 반복적으로 할당하고 해제하면 **메모리 단편화**가 발생할 수 있다. (메모리 단편화는 사용 가능한 메모리 공간이 충분해도 요청된 크기의 연속된 메모리 블록을 찾지 못하는 현상이다.)
 - 메모리 할당 및 해제 속도는 **스택 영역에 비해 상대적으로 느리다.** 이는 메모리 관리자가 적절한 메모리 블록을 찾고 할당하는 과정에 시간이 소요되기 때문
  
```cpp
#include <iostream>

int main() {
    int *dynamicArray = nullptr;
    int size = 10;

    dynamicArray = new int[size]; // 동적 메모리 할당

    if (dynamicArray == nullptr) {
        std::cout << "Memory allocation failed." << std::endl;
        return 1;
    }

    for (int i = 0; i < size; i++) {
        dynamicArray[i] = i + 1;
    }

    for (int i = 0; i < size; i++) {
        std::cout << "dynamicArray[" << i << "] = " << dynamicArray[i] << std::endl;
    }

    delete[] dynamicArray; // 메모리 해제

    return 0;
}
```
**아래는 동적 변수를 힙에 할당하는 이유이다.**
- 동적 변수의 크기가 동적으로 변경될 수 있어, 더 많은 메모리를 할당할 수 있는 점
- 프로그램이 종료될 때까지 할당된 메모리가 유지. 필요한 경우 메모리 해제를 수동으로 진행할 수 있는 점 (유연성)
- 힙 메모리의 크기는 스택보다 매우 크기 때문에, 큰 데이터 구조를 저장이 가능 한 점

## 데이터 영역
-------------
**데이터 영역(data segment)은 프로그램의 전역, 정적 변수및 상수 값을 저장하는 메모리 영역**
- 프로그램이 실행될 때 생성되고, 프로그램이 종료될 때 메모리에서 해제
- 초기화된 영역(DATA), 초기화 되지 않은 영역(BSS)으로 나뉜다.
- 상수 값은 읽기 전용 데이터 영역 (Read-Only Data Segment)에 저장된다. (이 영역은 데이터 영역의 일부이지만, 데이터를 수정할 수 없다는 점에서 다른 데이터 영역과 차이가 있다)
  
## 코드 영역
-----------
**실행할 프로그램의 코드가 저장되는 영역**
- 코드 영역은 메모리 구조에서 중요한 영역 중 하나로, 실행할 프로그램의 명령어들이 저장되는 영역이다. 
- 이 영역에는 기계어로 번역된 프로그램의 명령어들이 저장되며, CPU는 이 영역의 명령어를 순차적으로 가져와서 실행한다. 
- 코드 영역은 프로그램이 실행되는 동안 변경되지 않는 읽기 전용 메모리에 위치해 있다.
  
# 정리
-------------
1. 스택 영역
   - 함수 호출과 관련된 데이터를 저장하는 영역
   - 자동 메모리 할당 및 해제
   - 후입선출(FILO) 구조
   - 지역 변수 및 매개 변수 저장
2. 힙 영역
   - 동적 메모리 할당을 위한 영역
   - 수동 메모리 할당 및 해제
   - 크기 조절 가능
   - 포인터를 이용한 접근
3. 데이터 영역
   - 전역 변수와 정적 변수를 저장하는 영역
   - 프로그램 실행 시 할당, 종료시 해제
   - 전역 변수 및 정적 변수 저장
4. 코드 영역
   - 프로그램의 실행 코드(기계어로 번역된 명령어)가 저장
   - 읽기 전용 (실행 중에 변경 불가)