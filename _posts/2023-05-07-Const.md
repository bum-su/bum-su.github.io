---
layout: post
title: c++ Const 키워드
date: 2023-05-07 14:00:00 +0900
categories: C++ Const
tags: [Const Pointer]
---

# 서론
--------
C++에서 const 키워드는 변수를 상수로 선언하는 데 사용된다. <br/>상수는 한 번 값이 할당되면 변경할 수 없는 변수로, 프로그램에서 값 변경을 할 수 없다.

## 그럼 왜 사용하는가?
-----------
- 읽기 전용 변수

```cpp
double Pi = 3.141592;
```
읽기 전용 변수로 만들어 변수 값이 예기치 않게 변경되는 것을 방지해 준다.
<br/><br/>

- 함수 인수로 전달할 때 값 보호

```cpp
void foo(const int& a) {
    // a 값을 변경할 수 없음
}
```
함수내에서 인수의 값을 변경하지 않도록 보장해 준다.<br/><br/>

- 클래스 멤버 함수에서 사용

```cpp
class MyClass {
public:
    int getValue() const {
        // 멤버 변수를 변경할 수 없음
    }
};
```
해당 함수가 멤버 변수를 변경할 수 없음을 나타낸다. 이를 통해 해당 함수가 상태를 변경하지 않는 것을 보장한다.
<br/><br/>
**예기치 않은 상황을 미리 방지하고 싶은 것을 위해 사용한다.**<br/><br/>

# Const와 포인터
------------
사실 이 것을 위한 글이었다.<br/>
개념은 쉽지만 헷갈리게 만들어 놔서 잘 숙지하길 바란다.<br/>

```cpp
const int == int const
```
이건 그냥 상수다. 같다. 같은 의미다.

- **상수 포인터**

```cpp
const int* == int const*
```
const 뒷쪽에 포인터가 붙으면 상수 포인터라고 생각하면 된다. <br/>
포인터가 가리키는 주소를 바꿀 수는 있지만 **포인터가 가리키는 주소의 값을 바꿀 수는 없다.** <br/> 즉, 포인터가 가리키는 주소의 값만 상수화 시킨 것이다.
```cpp
int a = 5, b = 7;

const int* c_int1 = &a;

// *c_int1 = 6; error!! (포인터가 가리키는 주소의 값은 상수다!!)

c_int1 = &b; // 요건 가능 (포인터가 가리키는 주소를 바꾸는 것은 가능)

int const* c_int2 = &a;

// *c_int2 = 6; error!! (포인터가 가리키는 주소의 값은 상수다!!)

c_int2 = &b; // 요건 가능 (포인터가 가리키는 주소를 바꾸는 것은 가능)
```

- **포인터 상수**

```cpp
int* const
```
요거 하나 뿐이다. 포인터 상수는 const 키워드 앞쪽에 포인터가 붙은 것이라고 생각하자.<br/> 포인터가 가리키는 주소의 값을 바꿀 수는 있지만 **포인터가 가리키는 주소를 바꿀 수는 없다.** <br/> 즉, 포인터가 가리키는 주소만 상수화 시킨 것이다.
```cpp
int a = 5, b = 7;

int* const c_int = &a;

*c_int = 6; // 요건 가능 (포인터가 가리키는 주소의 값은 상수가 아니다!!)

//c_int = &b; error!! (포인터가 가리키는 주소는 상수다!!)
```
<br/><br/>
마지막이다.
- const int* const == int const * const
  - 요거 2개는 같다. 같은 의미다.
  - 포인터가 가리키는 주소도 상수. 포인터가 가리키는 주소의 값 또한 상수이다.

```cpp

int a = 5, b = 7;

const int* const c_int1 = &a;

// *c_int1 = 6; error!!

// c_int1 = &b; error!!

int const* const c_int2 = &a;

// *c_int2 = 6; error!!

// c_int2 = &b; error!!
```

### 결론
--------------
const 키워드는 상당히 자주 쓰인다. 그 이유는
- 코드의 안정성을 높여주고
- 컴파일러가 더 효율적인 최적화를 수행 할 수 있다.
  - 컴파일러는 해당 변수를 불변으로 취급하여 불필요한 메모리 액세스를 줄일 수 있고
  - 객체의 내부 상태를 변경하지 않는 것이 보장되기 때문에, 컴파일러가 함수 호출 결과를 캐시하거나 인라인 함수로 치환하는 등의 최적화를 수행할 수 있기 때문이다.

**외워두자**