---
layout: post
title: C++ 함수 호출 규약(Calling Convention)
date: 2023-05-09 15:00:00 +0900
categories: C++ Calling_Convention
tags: Calling_Convention
---

# 함수 호출 규약이란?
-----------
함수 호출 규약은 컴파일러가 함수를 호출하고 결과를 반환하는 방법을 정의하는 규칙이다. 

이는 호출자와 피호출자 간의 인터페이스를 제공하며, 이 인터페이스는 스택 정리, 매개변수 전달 순서, 반환 값 처리 등을 명시한다.

C++에서는 주로 네 가지 함수 호출 규약이 사용된다: __cdecl, __stdcall, __fastcall, __thiscall.

그 전에 알아야 할 것들이 있다.

<br>

# 스택 프레임
------------

스택 프레임은 컴퓨터 프로그램에서 서브루틴 혹은 함수 호출 시에 메모리 스택에 할당되는 자료 구조입니다. 각 스택 프레임은 함수 호출에 필요한 정보를 포함하며, 그 정보는 일반적으로 다음과 같습니다:

1. 함수 매개변수: 함수가 호출될 때 전달되는 인자입니다.
2. 리턴 주소: 함수 호출이 끝나고 제어가 돌아갈 위치를 가리키는 주소입니다.
3. 지역 변수: 특정 함수 내에서만 사용되는 변수입니다.
4. 프레임 포인터: 이전 스택 프레임을 가리키는 포인터입니다.

스택 프레임은 EBP와 ESP라는 두 가지 레지스터를 사용하여 관리됩니다. EBP는 현재 스택 프레임의 시작 지점을 가리키고, ESP는 스택의 맨 꼭대기(즉, 가장 최근에 푸시된 항목)를 가리킵니다.

```
  High Address
  +-----------------+
  |   이전 함수의   |
  |   스택 프레임   |
  |   ...          |
  +-----------------+  ← 이전 함수의 EBP
  |   이전 EBP 값   |
  +-----------------+  ← 현재 함수의 EBP
  |   지역 변수     |
  +-----------------+
  |   함수 인자     |
  +-----------------+
  |   리턴 주소     |
  +-----------------+  ← 현재 함수의 ESP
  |   다음 함수의   |
  |   스택 프레임   |
  |   ...          |
  Low Address
```

# EBP, ESP
-----------
EBP (Extended Base Pointer): EBP 레지스터는 베이스 포인터라고도 하며, 현재 함수의 스택 프레임을 가리키는 데 사용됩니다. 스택 프레임은 함수 호출 시 생성되며, 지역 변수와 함수 인자, 이전 함수의 EBP 값을 저장하는 공간입니다. EBP는 현재 함수의 스택 프레임의 기준점이 되어, 지역 변수와 인자에 접근할 때 상대적인 주소를 사용할 수 있게 합니다.

ESP (Extended Stack Pointer): ESP 레지스터는 스택 포인터라고도 하며, 현재 스택의 맨 위(가장 최근에 삽입된 항목)를 가리키는 데 사용됩니다. 함수 호출 시 인자가 스택에 푸시되고, 함수 호출이 끝난 후 리턴 주소가 스택에 저장됩니다. 또한, 함수 호출 도중에 지역 변수를 할당하기 위해서도 스택이 사용되며, 이 때 ESP가 이러한 스택 영역을 추적합니다.

## __cdecl
----------------
C와 C++에서 가장 일반적으로 사용되는 기본 함수 호출 규약입니다. cdecl은 "C declaration"의 약자로, C언어 선언 방식을 따르는 것을 의미합니다.

1. 함수의 인자를 오른쪽에서 왼쪽으로 스택에 push합니다.
2. 호출자(caller)가 함수의 스택을 정리합니다.

```cpp
#include <iostream>

void __cdecl Add(int a, int b) {
    std::cout << "두 정수의 합: " << (a + b) << std::endl;
}

int main() {
    Add(3, 5);
    return 0;
}
```
1. 함수 인자 푸시: 함수 인자들이 오른쪽에서 왼쪽 순서로 스택에 푸시됩니다. (b, a 순서로)
2. 리턴 주소 푸시: 호출된 함수가 종료된 후 돌아갈 리턴 주소가 스택에 푸시됩니다.
3. EBP 저장과 설정: 이전 함수의 EBP 값이 스택에 저장되고, 현재 ESP 값이 새 EBP 값으로 설정됩니다.
4. 지역 변수 할당: 스택에 지역 변수를 위한 공간이 할당됩니다.
5. 함수 실행: 함수가 실행되고, 필요한 경우 EBP를 기준으로 스택에 접근합니다.
6. EBP 복원과 리턴 주소 팝: 함수 종료 시 EBP 값이 복원되고, 리턴 주소가 스택에서 팝되어 제어가 호출자로 돌아갑니다.
7. 스택 정리: 호출자가 함수 인자를 스택에서 제거함으로써 스택을 정리합니다.

## __stdcall
-------------
Win32 API에서 주로 사용되는 함수 호출 규약입니다. __stdcall은 "Standard Calling"의 약자로, 표준 호출 방식을 따르는 것을 의미한다.

1. 함수의 인자를 왼쪽에서 오른쪽으로 스택에 push합니다.
2. 호출된 함수가 스택을 정리합니다.

```cpp
#include <iostream>

void __stdcall Add(int a, int b) {
    std::cout << "두 정수의 합: " << (a + b) << std::endl;
}

int main() {
    Add(3, 5);
    return
}
```

1. 함수 인자 푸시: 함수 인자들이 오른쪽에서 왼쪽 순서로 스택에 푸시됩니다.
2. 리턴 주소 푸시: 호출된 함수가 종료된 후 돌아갈 리턴 주소가 스택에 푸시됩니다.
3. EBP 저장과 설정: 이전 함수의 EBP 값이 스택에 저장되고, 현재 ESP 값이 새 EBP 값으로 설정됩니다.
4. 지역 변수 할당: 스택에 지역 변수를 위한 공간이 할당됩니다.
5. 함수 실행: 함수가 실행되고, 필요한 경우 EBP를 기준으로 스택에 접근합니다.
6. EBP 복원과 리턴 주소 팝: 함수 종료 시 EBP 값이 복원되고, 리턴 주소가 스택에서 팝되어 제어가 호출자로 돌아갑니다.
7. 스택 정리: 피호출자(즉, 호출된 함수)가 함수 인자를 스택에서 제거함으로써 스택을 정리합니다.

### ECX, EDX를 먼저 알고가자
-----------------
**ECX**는 "Count Register"의 약자로, 원래는 루프 카운트에 사용되는 레지스터였습니다. 즉, 반복 실행되는 명령어의 횟수를 저장하는 데 주로 사용되었습니다. 

그러나 현대의 프로그래밍에서는 ECX 레지스터를 범용 레지스터로 사용하며, 여러 다른 용도로 사용될 수 있습니다. 예를 들어, __fastcall와 __thiscall 호출 규약에서는 인자 전달에 ECX 레지스터를 사용합니다.


**EDX**는 "Data Register"의 약자로, 원래는 I/O 포트 주소나 연산 결과를 저장하는 데 사용되는 레지스터였습니다. 

현대의 프로그래밍에서는 EDX 레지스터를 범용 레지스터로 사용하며, 여러 다른 용도로 사용될 수 있습니다. 예를 들어, __fastcall 호출 규약에서는 두 번째 인자를 전달하는 데 EDX 레지스터를 사용합니다.


**그냥 메모리에 접근하는 것보다 레지스터에 접근하는 것이 더 빠르고, 함수 호출의 속도를 향상시켜주기 때문이라고 생각하면 된다.**

## __fastcall
------------
__fastcall 규약은 함수 호출의 속도를 최적화하기 위해 설계된 함수 호출 규약입니다.

1. 함수의 처음 두 개의 정수 인자를 레지스터(ECX, EDX)에 전달합니다.
2. 그 이후의 인자들은 스택에 push합니다.
3. 호출된 함수가 스택을 정리합니다.

__fastcall 규약은 함수 호출 속도를 최적화하는데 초점을 맞추고 있지만, 모든 매개변수를 레지스터에 할당할 수 없을 때는 스택을 사용해야 하므로 주의가 필요합니다.

```cpp
#include <iostream>

void __fastcall Add(int a, int b) {
    std::cout << "두 정수의 합: " << (a + b) << std::endl;
}

int main() {
    Add(3, 5);
    return 0;
}
```
1. 함수 인자 설정: 첫 번째와 두 번째 인자는 각각 ECX와 EDX 레지스터에 전달되며, 그 외의 인자들은 오른쪽에서 왼쪽 순서로 스택에 푸시됩니다.
2. 리턴 주소 푸시: 호출된 함수가 종료된 후 돌아갈 리턴 주소가 스택에 푸시됩니다.
3. EBP 저장과 설정: 이전 함수의 EBP 값이 스택에 저장되고, 현재 ESP 값이 새 EBP 값으로 설정됩니다.
4. 지역 변수 할당: 스택에 지역 변수를 위한 공간이 할당됩니다.
5. 함수 실행: 함수가 실행되고, 필요한 경우 EBP를 기준으로 스택에 접근합니다.
EBP 복원과 리턴 주소 팝: 함수 종료 시 EBP 값이 복원되고, 리턴 주소가 스택에서 팝되어 제어가 호출자로 돌아갑니다.
6. 스택 정리: 피호출자(즉, 호출된 함수)가 스택에 남아 있는 함수 인자를 제거함으로써 스택을 정리합니다.

## __thiscall
---------------
__thiscall 규약은 클래스의 멤버 함수를 호출할 때 사용되는 함수 호출 규약입니다.

1. 클래스의 멤버 함수에는 암시적으로 this 포인터가 전달됩니다.
2. this 포인터는 ECX 레지스터에 전달됩니다.
3. 함수의 인자는 스택에 push됩니다.
4. 호출된 함수가 스택을 정리합니다.

```cpp
#include <iostream>

class MyClass {
public:
    void __thiscall Add(int a, int b) {
        std::cout << "두 정수의 합: " << (a + b) << std::endl;
    }
};

int main() {
    MyClass myObj;
    myObj.Add(3, 5);
    return 0;
}
```
1. this 포인터 설정: this 포인터가 ECX 레지스터에 설정됩니다.
2. 함수 인자 푸시: 함수 인자들이 오른쪽에서 왼쪽 순서로 스택에 푸시됩니다. 
3. 리턴 주소 푸시: 호출된 함수가 종료된 후 돌아갈 리턴 주소가 스택에 푸시됩니다.
4. EBP 저장과 설정: 이전 함수의 EBP 값이 스택에 저장되고, 현재 ESP 값이 새 EBP 값으로 설정됩니다.
5. 지역 변수 할당: 스택에 지역 변수를 위한 공간이 할당됩니다.
6. 함수 실행: 함수가 실행되고, 필요한 경우 EBP를 기준으로 스택에 접근합니다.
7. EBP 복원과 리턴 주소 팝: 함수 종료 시 EBP 값이 복원되고, 리턴 주소가 스택에서 팝되어 제어가 호출자로 돌아갑니다.
8. 스택 정리: 피호출자(즉, 호출된 함수)가 함수 인자를 스택에서 제거함으로써 스택을 정리합니다.

<br/>

# 이걸 왜 사용하는 가?
-----------
첫째, 이 규약을 통해 컴파일러가 함수 호출을 어떻게 처리할지 알 수 있다. 

둘째, 이 규약은 프로그램의 실행 시간과 메모리 사용량을 최적화하는 데 도움이 된다.